#!/usr/bin/env python

# __author__ = Firas S Midani
# __email__ = midani@bcm.edu

# Midani et al. (2020) Figures 1A and 1B are generated by this script 

import os
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

from scipy.stats import norm
from matplotlib.patches import ConnectionPatch

sns.set_style('whitegrid')

def read_csv(foo):
  '''
  Read tab-separated file with header and index column.
  '''

  return pd.read_csv(foo,sep='\t',header=0,index_col=0)


def getLatentFunction(df,order=0,add_noise=False):
    '''
    Get arrays for time, mean, lower and upper bounds of confidence interval. 

    Args:
      df (pandas.DataFrame): in the format of gp_data from AMiGA, so columns must
        include 'mu','mu1','Sigma','Sigma1','Noise'.
      order (int): choose zero-order (0) or fist-order derivative (1).
      add_noise (boolean): whether to include estimated noise to confidence intervals.
    '''

    time = df.Time.values
    
    if order==0:
        mu = df.mu.values
        Sigma = df.Sigma.values
        if add_noise: Sigma = Sigma + df.Noise.values
    else:
        mu = df.mu1.values
        Sigma = df.Sigma1.values
    
    confidence = 0.95
    alpha = 1 - confidence
    z_value = 1-alpha/2
    scaler = norm.ppf(z_value)
    
    low = mu - scaler*np.sqrt(Sigma)
    upp = mu + scaler*np.sqrt(Sigma) 
    
    return time,mu,low,upp


###################
# Panels A and B #
###################

# import data and model estimates
split = './death/derived/CD1007_Low_Fructose_split_gp_data.txt'
poold ='./death/derived/CD1007_Low_Fructose_pooled_gp_data.txt'
split = read_csv(split)
poold = read_csv(poold)
raw = split.pivot(index='Time',columns='Sample_ID',values='GP_Input')

# import GP model summary
summ = './death/summary/CD1007_Low_Fructose_pooled_summary.txt'
summ = read_csv(summ)
summ = summ.to_dict('records')[0]

# extact GP model input
model_input = split.pivot(values='GP_Input',index='Time',columns='Sample_ID')

# initialize figure and axes
fig, axes = plt.subplots(2,2,figsize=[16,12],sharey=False)

ax = axes[:,0]

ax[0].set_zorder(1)
ax[1].set_zorder(0)


# plot OD(t)
ax[0].plot(poold.Time,poold.mu,color=(0.11,0.62,0.47,.8),lw=5,zorder=10)
ax[0].fill_between(x=poold.Time.values,
                   y1=[0]*poold.mu.shape[0],
                   y2=poold.mu.values,
                   color=(0.11,0.62,0.47,0.06))
#ax[0].plot(raw.index,raw.values,ls='-',lw=2,color=(.0,.0,.0,.5))
ax[0].axhline(0,0,1,color=(.0,.0,.0,.8),ls='-',lw=2)


# plot dOD(t)/dt
ax[1].plot(poold.Time,poold.mu1,color=(0.11,0.62,0.47,.8),lw=5,zorder=10)
ax[1].axhline(0,0,1,color=(.0,.0,.0,.8),ls='-',lw=2)

	
# adjust ticks and labels
def largeTickLabels(ax): [ii.set(fontsize=20,fontname='Arial') for ii in ax.get_xticklabels()+ax.get_yticklabels()]

largeTickLabels(ax[0])
largeTickLabels(ax[1])

plt.setp(ax[0],yticks=np.linspace(0,2,5));
plt.setp(ax[0],yticks=np.linspace(0,2,5));

plt.setp(ax[1],yticks=np.linspace(-0.2,0.4,7));
plt.setp(ax[1],yticks=np.linspace(-0.2,0.4,4));

ax[1].set_xlabel('Time (hours)',fontsize=20)
ax[0].set_ylabel('ln OD',fontsize=20)
ax[1].set_ylabel('d/dt  ln OD',fontsize=20)
#t = ax[0].set_title('RT053 isolate on 20 mM fructose',fontsize=20,y=1.05)

# adjust window limits
ax[0].set_xlim([0,25])
ax[1].set_xlim([0,25])
ax[0].set_ylim([-0.05,2.30])
ax[1].set_ylim([-0.22,0.52])


# get parameters and related coordinates

x_gr = summ['t_gr'] # t_gr, time at maximum growth rate
x_dr = summ['t_dr'] # t_dr, time at maximum death rate
x_k = summ['t_k'] # t_k, time at maximum growth/OD
x_lagC = summ['lagC']
x_lagP = summ['lagP']

od_x_gr = poold[poold.Time==x_gr].mu.values[0] # OD(t) at t_gr
od_x_dr = poold[poold.Time==x_dr].mu.values[0] # OD(t) at t_dr
od_x_k = poold[poold.Time==x_k].mu.values[0]
od_x_end = poold[poold.Time==poold.Time.max()].mu.values[0]

dod_x_gr = poold[poold.Time==x_gr].mu1.values[0] # dOD(t)/dt at t_gr
dod_x_dr = poold[poold.Time==x_dr].mu1.values[0] # dOD(t)/dt at t_dr

x00,x01 = ax[0].get_xlim() # min and max of y-axis for OD(t) plot
y00,y01 = ax[0].get_ylim() # min and max of y-axis for OD(t) plot
y10,y11 = ax[1].get_ylim() # min and max of y-axis for OD(t) plot

rel_x_k = (x_k - x00) / (x01 - x00)
rel_od_x_k = (od_x_k - y00) / (y01 - y00)
rel_od_x_gr = (od_x_gr - y00) / (y10 - y00) # od_x_gr in terms of axis fraction
rel_od_x_dr = (od_x_dr - y00) / (y10 - y00) # od_x_dr in terms of axis fraction 
rel_od_x_end = (od_x_end - y00) / (y01 - y00)

## annotate death
ax[0].axhline(od_x_k,rel_x_k,.99,ls='--',lw=2,color=(.5,.5,.5,.5))

dtha = ax[0].annotate('', xycoords='axes fraction',xytext=(1., rel_od_x_k), xy=(1., rel_od_x_end), 
                     arrowprops=dict(arrowstyle="<->",color='k',lw=2))#color='k',width=2))
dthl = ax[0].text(transform=ax[0].transAxes,x=1.02,va='center',ha='left',s='Death',
				 y=rel_od_x_end+0.5*(rel_od_x_k-rel_od_x_end),fontsize=20)


## annnotate carrying capacity
arrowprops = dict(connectionstyle="angle3,angleA=0,angleB=90",width=2,color='black')
ax[0].annotate('Carrying\nCapacity',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_k,od_x_k),xytext=(15,1.1),arrowprops=arrowprops)
ax[0].axvline(x_k,(0-y00)/(y01-y00),rel_od_x_k,ls='--',lw=2,color=(.5,.5,.5,.5))


## annotate doubling time
# arrowprops = dict(connectionstyle="angle3,angleA=0,angleB=90",width=2,color='black')
# ax[1].annotate('Doubling Time = ln(2) / r',fontsize=20,color='k',ha='left',va='center',zorder=25,
#               xycoords='data',xy=(x_gr,dod_x_gr),xytext=(10,0.5),arrowprops=arrowprops)


## annnotate maximum growth rate
arrowprops = dict(connectionstyle="angle3,angleA=90,angleB=0",width=2,color='black')
ax[1].annotate('Max.\nGrowth\nRate',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_gr,dod_x_gr),xytext=(13,0.25),arrowprops=arrowprops)


## annnotate maximum death rate
arrowprops = dict(connectionstyle="angle3,angleA=0,angleB=90",width=2,color='black')
ax[1].annotate('Max.\nDeath\nRate',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_dr,dod_x_dr),xytext=(19,0.1),arrowprops=arrowprops)


## add time at maximum growth rate
con = ConnectionPatch(coordsA="data",axesA=ax[0],xyA=(x_gr,od_x_gr),
                      coordsB="data",axesB=ax[1],xyB=(x_gr,0),
                      ls='--',lw=2,color=(.5,.5,.5,.5),zorder=0,clip_on=False)
ax[0].add_artist(con)


## add time at maximum death rate
ax[1].axvline(x_dr,(dod_x_dr-y10)/(y11-y10),(0-y10)/(y11-y10),
              ls='--',lw=2,color=(.5,.5,.5,.5))


## annotate classical lag time
b = -1*dod_x_gr * x_lagC # y-intercept of tanget = -m*lagC
ynew1 = dod_x_gr*3.5 + b # y = mx+b
ynew2 = dod_x_gr*9.5 + b # y = mx+b
ax[0].plot([3.5,x_lagC,x_gr,9.5],[ynew1,0,od_x_gr,ynew2],
          ls='--',lw=2,color=(.0,.0,.0,.8),clip_on=False)
ax[0].annotate('Lag\nTime',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_lagC,0),xytext=(2,0.5),arrowprops=arrowprops)


## annotate probabilistic lag time
ax[1].annotate('Adaptation Time',fontsize=20,color='k',ha='left',va='center',zorder=25,
              xycoords='data',xy=(x_lagP,0),xytext=(2,-0.15),arrowprops=arrowprops)


## annotate area under the curve
ax[0].text(transform=ax[0].transAxes,x=.7,y=0.05,ha='center',
           s='Area Under the\nCurve (AUC)',fontsize=20)


## annotate dOD/dt directions
d1 = ax[1].annotate('', xytext=(1.1, 2.35/7.4), xycoords='axes fraction', xy=(1.1, 1.), 
                   arrowprops=dict(color='k',width=2))
d2 = ax[1].annotate('', xytext=(1.1, 2.05/7.4), xycoords='axes fraction', xy=(1.1, 0.), 
                   arrowprops=dict(color='k',width=2),zorder=30)

d1l = ax[0].text(transform=ax[1].transAxes,x=1.15,y=4.8/7.4,va='center',s='Growth Rate',
                fontsize=20,rotation=270)
d2l = ax[0].text(transform=ax[1].transAxes,x=1.15,y=1.1/7.4,va='center',s='Death Rate',
                fontsize=20,rotation=270)


## adjust general figue aesthetics

[ax[0].spines[ii].set(lw=0) for ii in ['top','bottom','right']]
[ax[1].spines[ii].set(lw=0) for ii in ['top','bottom','right']]

ax[0].spines['left'].set(lw=2,color=(0,0,0,0.8))
ax[1].spines['left'].set(lw=2,color=(0,0,0,0.8))

ax[0].grid(False)
ax[1].grid(False)

##################
# Panels C and D #
##################

# read model estimated parameters
summ_df ='./death/summary/CD2058_Low_Glucose_pooled_summary.txt'
diux_df = './death/summary/CD2058_Low_Glucose_pooled_diauxie.txt'
summ_df = read_csv(summ_df)
diux_df = read_csv(diux_df)


# read model input and prediction of curves
split_df ='./death/derived/CD2058_Low_Glucose_split_gp_data.txt'
poold_df = './death/derived/CD2058_Low_Glucose_pooled_gp_data.txt'
    
split = read_csv(split_df)
poold = read_csv(poold_df)

ax = axes[:,1]

# plot OD(t)
ax[0].plot(poold.Time,poold.mu,color=(0.11,0.62,0.47,.8),lw=5,zorder=5)
t,mu,low,upp = getLatentFunction(poold,order=0,add_noise=True)
ax[0].fill_between(t,low,upp,color=(0.11,0.62,0.47,0.1),zorder=2)
ax[0].axhline(0,0,1,color=(.0,.0,.0,.8),ls='-',lw=2)

# plot dOD(t)/dt
ax[1].plot(poold.Time,poold.mu1,color=(0.11,0.62,0.47,.8),lw=5,zorder=5)
ax[1].axhline(0,0,1,color=(.0,.0,.0,.8),ls='-',lw=2)

# plot raw measurements
raw = split.pivot(index='Time',columns='Sample_ID',values='GP_Input')
ax[0].plot(raw.index,raw.values,color=(0.5,0.5,0.5,.8))


# adjust ticks and labels
def largeTickLabels(ax): [ii.set(fontsize=20,fontname='Arial') for ii in ax.get_xticklabels()+ax.get_yticklabels()]
largeTickLabels(ax[0])
largeTickLabels(ax[1])

plt.setp(ax[0],yticks=np.linspace(0,3,4),zorder=4);
plt.setp(ax[0],yticks=np.linspace(0,2,5),zorder=4);

plt.setp(ax[1],yticks=np.linspace(-0.2,0.6,5));
plt.setp(ax[1],yticks=np.linspace(-0.2,0.4,4));

ax[1].set_xlabel('Time (hours)',fontsize=20)
ax[0].set_ylabel('ln OD',fontsize=20)
ax[1].set_ylabel('d/dt  ln OD',fontsize=20)
#t = ax[0].set_title('CD2058 on 20 mM glucose',fontsize=20,y=1.05)


# adjust window limits
ax[0].set_xlim([0,25])
ax[1].set_xlim([0,25])
ax[0].set_ylim([-0.05,2.30])
ax[1].set_ylim([-0.22,0.52])


# add phase divider
tshift = diux_df.loc[0,'dx_tf'].values[0]
ax[0].axvline(tshift,0,.99,ls='--',lw=2,color=(0,0,0,.8),zorder=1)
ax[1].axvline(tshift,0,.99,ls='--',lw=2,color=(0,0,0,.8),zorder=1)


# get unique phase parameters
xr1,xr2 = diux_df.loc[0,'dx_t_gr'].values
xk1,xk2 = diux_df.loc[0,'dx_t_k'].values
r1,r2 = diux_df.loc[0,'dx_gr'].values
K1,K2 = diux_df.loc[0,'dx_k_log'].values


# annotate carrying capacity and growth rate for each phase
x0 = tshift/2
x1 = tshift + (ax[0].get_xlim()[1]-tshift)/2
y0 = ax[0].get_ylim()[1]
y1 = ax[1].get_ylim()[1]

ax[0].text(x=x0,y=y0,va='top',ha='center',s='$K_1$ = {:.2f}'.format(K1),fontsize=20,transform=ax[0].transData)
ax[0].text(x=x1,y=y0,va='top',ha='center',s='$K_2$ = {:.2f}'.format(K2),fontsize=20,transform=ax[0].transData)

ax[1].text(x=x0,y=y1,va='top',ha='center',s='$r_1$ = {:.2f}'.format(r1),fontsize=20,transform=ax[1].transData)
ax[1].text(x=x1,y=y1,va='top',ha='center',s='$r_2$ = {:.2f}'.format(r2),fontsize=20,transform=ax[1].transData)

## General figue aesthetics
[ax[0].spines[ii].set(lw=0) for ii in ['top','bottom','right']]
[ax[1].spines[ii].set(lw=0) for ii in ['top','bottom','right']]

ax[0].spines['left'].set(lw=2,color=(0,0,0,0.8))
ax[1].spines['left'].set(lw=2,color=(0,0,0,0.8))

ax[0].grid(False)
ax[1].grid(False)

# adjust spacing between panels
plt.subplots_adjust(hspace=0.23,wspace=0.8)

# add panel letters
axes[0,0].text(transform=axes[0,0].transAxes,x=-0.225,y=1,ha='left',va='top',s='A',fontsize=30,fontweight='bold')
axes[1,0].text(transform=axes[1,0].transAxes,x=-0.225,y=1,ha='left',va='top',s='B',fontsize=30,fontweight='bold')
axes[0,1].text(transform=axes[0,1].transAxes,x=-0.225,y=1,ha='left',va='top',s='C',fontsize=30,fontweight='bold')
axes[1,1].text(transform=axes[1,1].transAxes,x=-0.225,y=1,ha='left',va='top',s='D',fontsize=30,fontweight='bold')

# save figure as PDF and convert to EPS
filename = 'Midani_AMiGA_Figure_1'
plt.savefig('./figures/{}.pdf'.format(filename),bbox_extra_legends=(d1,d2,d1l,d2l,dtha,dthl),bbox_inches='tight')
