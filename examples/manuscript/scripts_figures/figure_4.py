#!/usr/bin/env python

# __author__ = Firas S Midani
# __email__ = midani@bcm.edu

# Midani et al. (2020) Figure 4 is generated by this script 

import sys
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from scipy.stats import norm

def read_csv(foo):
    return pd.read_csv(foo,sep='\t',header=0,index_col=0)

def largeTickLabels(ax,fontsize=20):
    [ii.set(fontsize=fontsize) for ii in ax.get_xticklabels()+ax.get_yticklabels()]
    
def subsetDf(df,criteria):
    
    for k,v in criteria.items():
        if not isinstance(v,list): criteria[k] = [v]
    
    return df[df.isin(criteria).sum(1)==len(criteria)]

def addSigs(ax,centers,values,color='k',label=None,width=0.66):
    
    width=width
    ls = [ii-width/2 for ii in centers]
    rs = [ii+width/2 for ii in centers]
    
    xmin,xmax = ax.get_xlim()
    xband = xmax-xmin
    for l,r,v in zip(ls,rs,values):
        ax.axhline(v,(l-xmin)/xband,(r-xmin)/xband,color=color,lw=3,zorder=10,label=label)

# read model differential testing resutls

parent ="./death"

subs = ["Glucose","Fructose"]
rts = ["RT001","RT053","RT027","RT078"]

ls_bf = []
idx_bf = pd.DataFrame(index=range(len(subs)*len(rts)),columns=['Substrate','Ribotype'])

count = 0
for sub in subs:
    for rt in rts:
        fname = '{}_LH_{}_y_c'.format(sub,rt)
        fname = '{}/models/{}/{}_log.txt'.format(parent,fname,fname)
        ls_bf.append(pd.read_csv(fname,sep='\t',header=0,index_col=0))
        idx_bf.loc[count,:] = [sub,rt]
        count+=1
        
bf = idx_bf.join(pd.concat(ls_bf,axis=0,sort=False).reset_index(drop=True))

tmp_bf = bf.loc[:,['Substrate','Ribotype','Log_BF','M1_FDR_cutoff','M0_FDR_cutoff','Func_Diff_Mean','Func_Diff_CI']]
tmp_bf = tmp_bf.sort_values(['Ribotype'])

# read model raw and predicted data
df_data = read_csv('{}/derived/pooled_gp_data.txt'.format(parent))
df_split = read_csv('{}/derived/split_gp_data.txt'.format(parent))
df_split_summ = read_csv('{}/summary/split_summary.txt'.format(parent))

# auxiliary functions 

def getLatentFunction(df,order=0,add_noise=False):
    '''
    Get arrays for time, mean, lower and upper bounds of confidence interval. 

    Args:
    	df (pandas.DataFrame): in the format of gp_data from AMiGA, so columns must
    		include 'mu','mu1','Sigma','Sigma1','Noise'.
    	order (int): choose zero-order (0) or fist-order derivative (1).
    	add_noise (boolean): whether to include estimated noise to confidence intervals.
    '''

    time = df.Time.values
    
    if order==0:
        mu = df.mu.values
        Sigma = df.Sigma.values
        if add_noise: Sigma = Sigma + df.Noise.values
    else:
        mu = df.mu1.values
        Sigma = df.Sigma1.values
            
    scaler = norm.ppf(0.95)
    
    low = mu - scaler*np.sqrt(Sigma)
    upp = mu + scaler*np.sqrt(Sigma) 
    
    return time,mu,low,upp

def computeFullDifference(x_diff,variable,confidence,noise=False):
    '''
    Computes the full difference between two latent function (modelling growth curves).

    Args:
        x_diff (pandas.DataFrame): must include columns of Time, mu (mean of latent 
            function), Sigma (diagonal covariance of latent function)
        variable (str): variable of interest, must be a column name in x_diff
        confidence (float [0.0,1.0]): confidence interval, e.g. 0.95 for 95%.
        n (int): number of samples from posterior distribution
        eirorposterior (boolean), whether to sample from posterior distribution
        noise (boolean): whetehr to plot 95-pct credibel intervals including sample uncertainty

    Returns:
        df (pandas.DataFrame)
        delta_od_sum (float): ||OD(t)||^2 which is defined as the sum of squares 
            for the OD when the mean and its credible interval deviates from zero.
    '''

    def buildTestMatrix(x_time):
        '''
        Build a test matrix to simlpify OD full difference computation.
            See https://github.com/ptonner/gp_growth_phenotype/testStatistic.py 
            This is used to compare two growth latent functions. The differeence between
            first time points (measurements) are adjusted to zero. 
        Args:
            x_time (pandas.DataFrame or pandas.Series or numpy.ndarray), ndim > 1
        Returns:
            A (numpy.ndarray): N-1 x 2*N where N is length of time.
        '''

        # buildtestmatrix
        n = x_time.shape[0]
        A = np.zeros((n-1,2*n))
        A[:,0] = 1
        A[range(n-1),range(1,n)] = -1
        A[:,n] = -1
        A[range(n-1),n+np.arange(1,n)] = 1

        return A

    from scipy.stats import norm
    
    scaler = norm.ppf(confidence) # define confidence interval scaler for MVN predictions

    x_diff = x_diff.sort_values([variable,'Time']) # do you really need to sort by variable
    x_time = x_diff.Time.drop_duplicates()

    # define mean and covariance of data
    mu = x_diff['mu'].values
    if noise: Sigma = np.diag(x_diff['Sigma'] + x_diff['Noise'])
    else: Sigma = np.diag(x_diff['Sigma'])

    # define mean and covariance of functional diffeence
    A = buildTestMatrix(x_time)
    m = np.dot(A,mu)
    c = np.dot(A,np.dot(Sigma,A.T))
    mean,std = m,np.sqrt(np.diag(c))

    # sample the curve for the difference between functions, from an MVN distribution
    n = 100 # number of posterior samples
    samples = np.random.multivariate_normal(m,c,n)

    pd.DataFrame(m).to_csv('/Users/firasmidani/Downloads/20201025_amiga_test/mu.txt',sep='\t')
    pd.DataFrame(samples).to_csv('/Users/firasmidani/Downloads/20201025_amiga_test/samples.txt',sep='\t')

    # compute the sum of functional differences for all sampled curves
    dos = [np.sqrt(np.sum([ii**2 for ii in s])) for s in samples]
    dos_mu, dos_std = np.mean(dos), np.std(dos)
    dos_actual = np.sqrt(np.sum([ii**2 for ii in m]))

    # compute the confidence interval for the sum of functional differences
    scaler = norm.ppf(confidence) # define confidence interval scaler for MVN predictions
    dos_ci = (dos_mu-scaler*dos_std, dos_mu+scaler*dos_std)

    # compute credible intervals
    y_avg = mean
    y_low = y_avg-scaler*std
    y_upp = y_avg+scaler*std

    # package results
    t = x_time[1:].values
    df = pd.DataFrame([t,y_avg,y_low,y_upp],index=['Time','Avg','Low','Upp']).T

    delta_od_sum_mean = dos_actual
    delta_od_sum_ci = dos_ci

    return df, delta_od_sum_mean, delta_od_sum_ci


# initialize figure
fig,axes_all = plt.subplots(2,5,figsize=[22,10],sharex=False,
                            gridspec_kw={'width_ratios':[1,0.15,1,0.15,1]})

# set parameters
fontsize = 20
width = 0.7

# plot summary metrics 
params = ['Func_Diff_Mean','Log_BF']
labels = [r'$\Vert OD\Delta\Vert$','ln Bayes Factor']
colors = ['#1f78b4',(0,0,0)]
alphas = [0.4,0.2]
cols = [2,4]

# get values
tmp0 = tmp_bf[tmp_bf.Substrate.isin(['Glucose'])]
tmp1 = tmp_bf[tmp_bf.Substrate.isin(['Fructose'])]

# define bar locations
centers0 = range(tmp0.shape[0])
centers1 = range(tmp1.shape[0])

bands0 = [eval(ii)[1]-jj for ii,jj in zip(tmp0['Func_Diff_CI'],tmp0['Func_Diff_Mean'])]
bands1 = [eval(ii)[1]-jj for ii,jj in zip(tmp1['Func_Diff_CI'],tmp1['Func_Diff_Mean'])]

# plot functional difference
axes_all[0,2].bar(centers0,tmp0[params[0]],yerr=bands0,
    color=colors[0],alpha=alphas[0],width=width)
axes_all[1,2].bar(centers1,tmp1[params[0]],yerr=bands1,
    color=colors[0],alpha=alphas[0],width=width)

# plot log BF
axes_all[0,4].bar(centers0,tmp0[params[1]],color=colors[1],alpha=alphas[1],width=width)
axes_all[1,4].bar(centers1,tmp1[params[1]],color=colors[1],alpha=alphas[1],width=width)

# adjust window x-axis labels with ribotype names
for ax in axes_all[:,[2,4]]: plt.setp(ax,xticks=centers0,xticklabels=tmp0.Ribotype.values)

axes_all[0,2].set_title(labels[0],fontsize=30,y=1.05)
axes_all[0,4].set_title(labels[1],fontsize=30,y=1.05)

# adjust figure aesthetics

axes_all[0,-1].yaxis.set(label_position="right") 
axes_all[1,-1].yaxis.set(label_position="right") 
axes_all[0,2].yaxis.set(label_position="right") 
axes_all[1,2].yaxis.set(label_position="right") 

axes_all[0,-1].set_ylabel('Glucose',fontsize=30,fontweight='normal',labelpad=20)
axes_all[1,-1].set_ylabel('Fructose',fontsize=30,fontweight='normal',labelpad=20)
axes_all[0,2].set_ylabel('Glucose',fontsize=30,fontweight='normal',labelpad=20)
axes_all[1,2].set_ylabel('Fructose',fontsize=30,fontweight='normal',labelpad=20)

for ax in np.ravel(axes_all):
    plt.setp(ax,yticks=np.linspace(0,8,5))
    ax.set_ylim([0,8])
    ax.set_xlim([-0.5,3.5])
    largeTickLabels(ax,fontsize=fontsize)

# adjust first column differently
[ax.set_yscale('log') for ax in axes_all[:,-1]];
[ax.set_ylim([10**-3,10**3]) for ax in axes_all[:,-1]];

# add fdr thesholds

# first get values
tmp0 = tmp_bf[tmp_bf.Substrate.isin(['Glucose'])]
tmp1 = tmp_bf[tmp_bf.Substrate.isin(['Fructose'])]

# second get locations
centers0 = range(tmp0.shape[0])
centers1 = range(tmp1.shape[0])

# finally add significnace thresholds as horizontal lines
addSigs(axes_all[0,-1],centers0,tmp0['M1_FDR_cutoff'],color=(0,0,0,0.8))
addSigs(axes_all[1,-1],centers1,tmp1['M1_FDR_cutoff'],color=(0,0,0,0.8))

## add example of functional difference in first column of subplots

# initialize parameters
criteria = {'Ribotype':['RT053'],'Substrate':['Fructose']}
add_noise = False
color_low = '#4daf4a'
color_high = '#984ea3'
color_diff = '#377eb8'
ax = axes_all[:,0]

# model prediction
#tmp = subsetDf(df_data,criteria)

model = '{}_LH_{}_y_c'.format(criteria['Substrate'][0],criteria['Ribotype'][0])
tmp = read_csv('{}/models/{}/{}_output.txt'.format(parent,model,model))
tmp_diff = read_csv('{}/models/{}/{}_func_diff.txt'.format(parent,model,model))

# get data
xy0 = tmp[tmp.Concentration=='Low']
xy1 = tmp[tmp.Concentration=='High']

# get itemized data
time0,mu0,low0,upp0 = getLatentFunction(xy0,order=0,add_noise=add_noise)
time1,mu1,low1,upp1 = getLatentFunction(xy1,order=0,add_noise=add_noise)
 
# add means and confidence intervals and legend
ax[0].plot(time0,mu0,color=color_low,lw=4,label='Low')
ax[0].plot(time1,mu1,color=color_high,lw=4,label='High')
ax[0].fill_between(time0,low0,upp0,color=color_low,alpha=0.1)
ax[0].fill_between(time0,low1,upp1,color=color_high,alpha=0.1)
ax[0].legend(fontsize=fontsize,loc='lower right',frameon=False)

# add full difference and its confidence interval
ax[1].plot(tmp_diff.Time,tmp_diff.Avg,color=color_diff,lw=4,zorder=3)
ax[1].fill_between(tmp_diff.Time,tmp_diff.Low,tmp_diff.Upp,color=color_diff,alpha=0.1,zorder=2)
ax[1].axhline(0,0,1,ls='-',lw=2,color='black',zorder=1)

# adjust window limits
ax[0].set_ylim([-0.25,2.25])
ax[1].set_ylim([-1,1])
ax[0].set_xlim([0,25])
ax[1].set_xlim([0,25])

# adjust tick labels
plt.setp(ax[0],yticks=np.linspace(0,2,5))
plt.setp(ax[1],yticks=np.linspace(-1,1,5))
plt.setp(ax[0],xticks=np.linspace(0,24,4))
plt.setp(ax[1],xticks=np.linspace(0,24,4))
[largeTickLabels(ax_ii) for ax_ii in ax];

# adjust axes labels and title
ax[1].set_xlabel('Time (hours)',fontsize=30)
ax[1].set_ylabel(r'$\Delta$ ln OD',fontsize=30)
ax[0].set_ylabel('ln OD',fontsize=30)
ax[0].set_title('RT053 on Fructose',fontsize=30,y=1.05)

# add actual curve used by model
criteria = {}
criteria['Low'] = {'Ribotype':['RT053'],'Substrate':['Fructose'],'Concentration':['Low']}
criteria['High'] = {'Ribotype':['RT053'],'Substrate':['Fructose'],'Concentration':['High']}

for conc,color in zip(['Low','High'],['green','purple']):
    tmp = subsetDf(df_split_summ,criteria[conc]).index.values
    tmp = subsetDf(df_split,{'Sample_ID':list(tmp)})
    tmp = tmp.pivot(index='Time',values='GP_Input',columns='Sample_ID')
    ax[0].plot(tmp.index.values,tmp.values,color=color,lw=0.5,alpha=0.5)
    
# remove second and fourth column of axes, which I deliberately need for whitespace
fig.delaxes(axes_all[0,1])
fig.delaxes(axes_all[1,1])
fig.delaxes(axes_all[0,3])
fig.delaxes(axes_all[1,3])

plt.subplots_adjust(wspace=0.25)
    
# save figure as PDF
filename = 'Midani_AMiGA_Figure_4'
plt.savefig('./figures/{}.pdf'.format(filename),bbox_inches='tight')