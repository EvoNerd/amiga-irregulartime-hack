#!/usr/bin/env python

# __author__ = Firas S Midani
# __email__ = midani@bcm.edu

# Midani et al. (2020) Figures 1A and 1B are generated by this script 

import os
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

from distutils.spawn import find_executable
from matplotlib.patches import ConnectionPatch

sns.set_style('whitegrid')

# import data and model estimates
split = './death/derived/CD1007_Low_Fructose_split_gp_data.txt'
poold ='./death/derived/CD1007_Low_Fructose_pooled_gp_data.txt'
split = pd.read_csv(split,sep='\t',header=0,index_col=0)
poold = pd.read_csv(poold,sep='\t',header=0,index_col=0)
raw = split.pivot(index='Time',columns='Sample_ID',values='GP_Input')

# import GP model summary
summ = './death/summary/CD1007_Low_Fructose_pooled_summary.txt'
summ = pd.read_csv(summ,sep='\t',header=0,index_col=0)
summ = summ.to_dict('records')[0]

# extact GP model input
model_input = split.pivot(values='GP_Input',index='Time',columns='Sample_ID')

# initialize figure and axes
fig, ax = plt.subplots(2,1,figsize=[6,12],sharey=False)

ax[0].set_zorder(1)
ax[1].set_zorder(0)


# plot OD(t)
ax[0].plot(poold.Time,poold.mu,color=(0.11,0.62,0.47,.8),lw=5,zorder=10)
ax[0].fill_between(x=poold.Time.values,
                   y1=[0]*poold.mu.shape[0],
                   y2=poold.mu.values,
                   color=(0.11,0.62,0.47,0.06))
#ax[0].plot(raw.index,raw.values,ls='-',lw=2,color=(.0,.0,.0,.5))
ax[0].axhline(0,0,1,color=(.0,.0,.0,.8),ls='-',lw=2)


# plot dOD(t)/dt
ax[1].plot(poold.Time,poold.mu1,color=(0.11,0.62,0.47,.8),lw=5,zorder=10)
ax[1].axhline(0,0,1,color=(.0,.0,.0,.8),ls='-',lw=2)

	
# adjust ticks and labels
def largeTickLabels(ax): [ii.set(fontsize=20,fontname='Arial') for ii in ax.get_xticklabels()+ax.get_yticklabels()]

largeTickLabels(ax[0])
largeTickLabels(ax[1])

plt.setp(ax[0],yticks=np.linspace(0,2,5));
plt.setp(ax[0],yticks=np.linspace(0,2,5));

plt.setp(ax[1],yticks=np.linspace(-0.2,0.4,7));
plt.setp(ax[1],yticks=np.linspace(-0.2,0.4,4));

ax[1].set_xlabel('Time (hours)',fontsize=20)
ax[0].set_ylabel('ln OD',fontsize=20)
ax[1].set_ylabel('d/dt  ln OD',fontsize=20)
#t = ax[0].set_title('RT053 isolate on 20 mM fructose',fontsize=20,y=1.05)

# adjust window limits
ax[0].set_xlim([0,25])
ax[1].set_xlim([0,25])
ax[0].set_ylim([-0.05,2.30])
ax[1].set_ylim([-0.22,0.52])


# get parameters and related coordinates

x_gr = summ['t_gr'] # t_gr, time at maximum growth rate
x_dr = summ['t_dr'] # t_dr, time at maximum death rate
x_k = summ['t_k'] # t_k, time at maximum growth/OD
x_lagC = summ['lagC']
x_lagP = summ['lagP']

od_x_gr = poold[poold.Time==x_gr].mu.values[0] # OD(t) at t_gr
od_x_dr = poold[poold.Time==x_dr].mu.values[0] # OD(t) at t_dr
od_x_k = poold[poold.Time==x_k].mu.values[0]
od_x_end = poold[poold.Time==poold.Time.max()].mu.values[0]

dod_x_gr = poold[poold.Time==x_gr].mu1.values[0] # dOD(t)/dt at t_gr
dod_x_dr = poold[poold.Time==x_dr].mu1.values[0] # dOD(t)/dt at t_dr

x00,x01 = ax[0].get_xlim() # min and max of y-axis for OD(t) plot
y00,y01 = ax[0].get_ylim() # min and max of y-axis for OD(t) plot
y10,y11 = ax[1].get_ylim() # min and max of y-axis for OD(t) plot

rel_x_k = (x_k - x00) / (x01 - x00)
rel_od_x_k = (od_x_k - y00) / (y01 - y00)
rel_od_x_gr = (od_x_gr - y00) / (y10 - y00) # od_x_gr in terms of axis fraction
rel_od_x_dr = (od_x_dr - y00) / (y10 - y00) # od_x_dr in terms of axis fraction 
rel_od_x_end = (od_x_end - y00) / (y01 - y00)

## annotate death
ax[0].axhline(od_x_k,rel_x_k,.99,ls='--',lw=2,color=(.5,.5,.5,.5))

dtha = ax[0].annotate('', xycoords='axes fraction',xytext=(1., rel_od_x_k), xy=(1., rel_od_x_end), 
                     arrowprops=dict(arrowstyle="<->",color='k',lw=2))#color='k',width=2))
dthl = ax[0].text(transform=ax[0].transAxes,x=1.02,va='center',ha='left',s='Death',
				 y=rel_od_x_end+0.5*(rel_od_x_k-rel_od_x_end),fontsize=20)


## annnotate carrying capacity
arrowprops = dict(connectionstyle="angle3,angleA=0,angleB=90",width=2,color='black')
ax[0].annotate('Carrying\nCapacity',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_k,od_x_k),xytext=(15,1.1),arrowprops=arrowprops)
ax[0].axvline(x_k,(0-y00)/(y01-y00),rel_od_x_k,ls='--',lw=2,color=(.5,.5,.5,.5))


## annotate doubling time
# arrowprops = dict(connectionstyle="angle3,angleA=0,angleB=90",width=2,color='black')
# ax[1].annotate('Doubling Time = ln(2) / r',fontsize=20,color='k',ha='left',va='center',zorder=25,
#               xycoords='data',xy=(x_gr,dod_x_gr),xytext=(10,0.5),arrowprops=arrowprops)


## annnotate maximum growth rate
arrowprops = dict(connectionstyle="angle3,angleA=90,angleB=0",width=2,color='black')
ax[1].annotate('Max.\nGrowth\nRate',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_gr,dod_x_gr),xytext=(13,0.25),arrowprops=arrowprops)


## annnotate maximum death rate
arrowprops = dict(connectionstyle="angle3,angleA=0,angleB=90",width=2,color='black')
ax[1].annotate('Max.\nDeath\nRate',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_dr,dod_x_dr),xytext=(19,0.1),arrowprops=arrowprops)


## add time at maximum growth rate
con = ConnectionPatch(coordsA="data",axesA=ax[0],xyA=(x_gr,od_x_gr),
                      coordsB="data",axesB=ax[1],xyB=(x_gr,0),
                      ls='--',lw=2,color=(.5,.5,.5,.5),zorder=0,clip_on=False)
ax[0].add_artist(con)


## add time at maximum death rate
ax[1].axvline(x_dr,(dod_x_dr-y10)/(y11-y10),(0-y10)/(y11-y10),
              ls='--',lw=2,color=(.5,.5,.5,.5))


## annotate classical lag time
b = -1*dod_x_gr * x_lagC # y-intercept of tanget = -m*lagC
ynew1 = dod_x_gr*3.5 + b # y = mx+b
ynew2 = dod_x_gr*9.5 + b # y = mx+b
ax[0].plot([3.5,x_lagC,x_gr,9.5],[ynew1,0,od_x_gr,ynew2],
          ls='--',lw=2,color=(.0,.0,.0,.8),clip_on=False)
ax[0].annotate('Lag\nTime',fontsize=20,color='k',ha='center',va='center',zorder=25,
              xycoords='data',xy=(x_lagC,0),xytext=(2,0.5),arrowprops=arrowprops)


## annotate probabilistic lag time
ax[1].annotate('Adaptation Time',fontsize=20,color='k',ha='left',va='center',zorder=25,
              xycoords='data',xy=(x_lagP,0),xytext=(2,-0.15),arrowprops=arrowprops)


## annotate area under the curve
ax[0].text(transform=ax[0].transAxes,x=.7,y=0.05,ha='center',
           s='Area Under the\nCurve (AUC)',fontsize=20)


## annotate dOD/dt directions
d1 = ax[1].annotate('', xytext=(1.1, 2.35/7.4), xycoords='axes fraction', xy=(1.1, 1.), 
                   arrowprops=dict(color='k',width=2))
d2 = ax[1].annotate('', xytext=(1.1, 2.05/7.4), xycoords='axes fraction', xy=(1.1, 0.), 
                   arrowprops=dict(color='k',width=2),zorder=30)

d1l = ax[0].text(transform=ax[1].transAxes,x=1.15,y=4.8/7.4,va='center',s='Growth Rate',
                fontsize=20,rotation=270)
d2l = ax[0].text(transform=ax[1].transAxes,x=1.15,y=1.1/7.4,va='center',s='Death Rate',
                fontsize=20,rotation=270)


## adjust general figue aesthetics
plt.subplots_adjust(hspace=0.23)

[ax[0].spines[ii].set(lw=0) for ii in ['top','bottom','right']]
[ax[1].spines[ii].set(lw=0) for ii in ['top','bottom','right']]

ax[0].spines['left'].set(lw=2,color=(0,0,0,0.8))
ax[1].spines['left'].set(lw=2,color=(0,0,0,0.8))

ax[0].grid(False)
ax[1].grid(False)


# save figure as PDF and convert to EPS
filename = 'Midani_AMiGA_Figure_1_ab'
plt.savefig('./figures/{}.pdf'.format(filename),bbox_extra_legends=(d1,d2,d1l,d2l,dtha,dthl),bbox_inches='tight')
